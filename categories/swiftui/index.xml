<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SwiftUI on Lagrange1813&#39;s Blog</title>
        <link>https://example.com/categories/swiftui/</link>
        <description>Recent content in SwiftUI on Lagrange1813&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Lagrange</copyright>
        <lastBuildDate>Fri, 22 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/categories/swiftui/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>使用 Coordinator 模式处理 SwiftUI 与 UIKit 混合导航</title>
        <link>https://example.com/p/coordinator-introduction/</link>
        <pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/coordinator-introduction/</guid>
        <description>&lt;img src="https://example.com/p/coordinator-introduction/neom-bhKqZNZeAR0-unsplash.jpg" alt="Featured image of post 使用 Coordinator 模式处理 SwiftUI 与 UIKit 混合导航" /&gt;&lt;h2 id=&#34;coordinator-模式&#34;&gt;&lt;code&gt;Coordinator&lt;/code&gt; 模式&lt;/h2&gt;
&lt;p&gt;2015 年，&lt;a class=&#34;link&#34; href=&#34;https://khanlou.com/2015/01/the-coordinator/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Soroush Khanlou&lt;/a&gt; 就向 Apple 社区介绍了 &lt;code&gt;Coordinator&lt;/code&gt; 模式这一概念。简而言之，这一模式将传统场景下由 UIViewController 承担的导航职责抽离为单独的部分，来避免 ViewController 的过度膨胀，并促进 ViewController 的重用。&lt;/p&gt;
&lt;p&gt;我们来看一下下面这段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tableView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tableView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UITableView&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;didSelectRowAt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;indexPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IndexPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;selectedItem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;indexPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;row&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;detailViewController&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DetailViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selectedItem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;navigationController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pushViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detailViewController&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;animated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上面的代码中，我们可以发现有两处耦合。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TableView&lt;/code&gt; 与 &lt;code&gt;DetailViewController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TableView&lt;/code&gt; 与 &lt;code&gt;UINavigationController&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们逐项分析。第一，&lt;code&gt;TableView&lt;/code&gt; 并不需要知道 &lt;code&gt;DetailViewController&lt;/code&gt; 的具体类型。如果在这里确定了 &lt;code&gt;DetailViewController&lt;/code&gt;，那么当 &lt;code&gt;TableView&lt;/code&gt; 复用并需要推出其他的视图控制器时，处理起来会变的棘手。抽象出基类并针对不同场景创建子类并重写方法？这并不是一个好的选择。&lt;/p&gt;
&lt;p&gt;第二，&lt;code&gt;TableView&lt;/code&gt; 其实也并不需要知道是谁负责导航。试想一下这样的场景：如果 &lt;code&gt;TableView&lt;/code&gt; 作为一个 &lt;code&gt;UISplitViewController&lt;/code&gt; 的 Primary Column，那么它的职责是在用点击相应的行时，在 Secondary Column 中推出细节视图控制器，这里的代码同样需要修改。&lt;/p&gt;
&lt;p&gt;如何解决以上的问题呢？我想可以抽离出导航部分的代码，创建为 &lt;code&gt;Coordinator&lt;/code&gt;。这样，在不同场景下，我们只需要创建相应的 &lt;code&gt;Coordinator&lt;/code&gt; 实例，就可以因地制宜的导航。&lt;/p&gt;
&lt;h2 id=&#34;swiftui-与-uikit-混合&#34;&gt;SwiftUI 与 UIKit 混合&lt;/h2&gt;
&lt;p&gt;随着 iOS 的不断发展，SwiftUI 逐渐在开发中被使用，&lt;code&gt;Coordinator&lt;/code&gt; 在处理 SwiftUI 与 UIKit 混合时的导航，同样有着优势。&lt;/p&gt;
&lt;p&gt;试想这样一个场景，我们需要在 A 视图控制器中，推出由 &lt;code&gt;UIHostingController&lt;/code&gt; 包装的 SwiftUI B 视图，又需要在 B 视图中，推出 C 视图控制器。&lt;/p&gt;
&lt;p&gt;看起来，可以有两种解决方案，在 B 视图中直接使用 NavigationLink 推出由 &lt;code&gt;UIViewRepresentable&lt;/code&gt; 封装的 C 视图控制器，或者向 B 视图中传入 &lt;code&gt;navigationController&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过实验，我们可以发现，可以直接在 B 视图中使用 &lt;code&gt;NavigationLink&lt;/code&gt; 导航到 C 视图控制器，并且包裹 A 视图控制器的 &lt;code&gt;UINavigationController&lt;/code&gt; 会自动作为 &lt;code&gt;NavigationView&lt;/code&gt; / &lt;code&gt;NavigationStack&lt;/code&gt; 与 &lt;code&gt;NavigationLink&lt;/code&gt; 配合生效。看起来 Apple 默默做的很好，但一旦事情变得复杂起来，例如需要 B 视图在 Secondary Column 中推出 C 视图控制器时，以上的两种方案均有问题。&lt;/p&gt;
&lt;p&gt;方案一中，我们无法找到 &lt;code&gt;showDetailViewController&lt;/code&gt; 在 SwiftUI 中的同等声明方式，因此无法实现相应的效果。而在方案二中，我们需要传入 &lt;code&gt;splitViewController&lt;/code&gt;，这导致视图变得更加复杂。&lt;/p&gt;
&lt;h2 id=&#34;coordinator-模式应对混合&#34;&gt;&lt;code&gt;Coordinator&lt;/code&gt; 模式应对混合&lt;/h2&gt;
&lt;p&gt;那么，不妨使用 &lt;code&gt;Coordinator&lt;/code&gt; 模式来处理上述问题。在这里，我们用 router 表示 SwiftUI视图 / UIKit视图控制器持有的 Coordinator 实例。&lt;/p&gt;
&lt;p&gt;我们在 SwiftUI 视图或者 UIKit 视图控制器创建时注入一个 router 实例，并在需要导航时，调用 router 的方法来处理导航。&lt;/p&gt;
&lt;p&gt;这样，在不同的使用场景下，我们可以给 SwiftUI 视图或者 UIKit 视图控制器注入不同的 router，来实现不同的导航；视图控制器也不需要考虑具体的导航方式和下一个视图，只需提供数据即可；SwiftUI 视图也只需要使用 router 来处理一切即可。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
